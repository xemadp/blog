<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>  Making A Compiler of My Own </title>
<style>
    body{
        margin:1em auto;
        max-width:40em;
        padding:0 .62em;
        font: sans-serif
    }
    blockquote, pre, code {
        background-color: #f0f0f0;
        border-color: #222;
    }
    h1,h2,h3 {
        line-height:1.2;
    }
    @media print{
        body{
            max-width:none
        }
    }
    @media (prefers-color-scheme: dark){
        body {color:#fff;background:#111}
        a:link {color:#cdf}
        a:hover, a:visited:hover {color:#def}
        a:visited {color:#dcf}
        blockquote, pre, code {
                background-color: #2f2f2f;
        }
    }
</style>

<body>
    <div>
        
<!---Generated by esbu--->


<!---the creation date is: 2024-11-21 06:58:21 --->


<h1>Making A Compiler of My Own</h1>

<p>During the last summer, I got into thinking; What would a program language look like
if it would be designed to perform euclidean construction only?</p>

<p><p align="center" style="line-height:1.5">
<img src="../pics/compass.png" alt="Compass"  style="width:100%;height:auto;max-width:900px" />
</p></p>

<p>The programming language would be assumed to only have a &ldquo;Straightedge&rdquo; and a &ldquo;Compass&rdquo;, and try to reason about certain input streams ( programs ).
Is the provided construnction in the program correct? And other such questions.
This got me into thinking and researching a lot about programming languages, designing them and of course compilers.
I read more and more about compilers, and I got enticed enough to pick it up as a lesson in the current semester (five) of Uni.
When given more thought, I decided I want to learn more about formal methods, theorem provers like coq and agda and so fourth.</p>

<p>I finally settled with this: Make a programming language to do
basic formal verification in Automata Theory.
In order not to neglect my new found love for compilers,
I decided to start at just that.
Making a compiler for a language ( yet to be named ), that does just what I mentioned earlier.</p>

<h1>Formal Verification of Automata</h1>

<p>The idea is that, given a program consisting of automata declarations and then some verification statements, prove or disprove the given statements.
I&rsquo;ve decided to use lex/bison for the lexical analyzer generator
and parser respectively.</p>

<p>So far I&rsquo;ve been working on a lexical analyzer. And I&rsquo;ve come up with the current language specification:</p>

<p><pre><code>program = { automaton_declaration | verification_declaration };

automaton_declaration = "Automaton" identifier "{"
state_declaration
start_state
accept_states
alphabet_declaration 
{ transition_declaration }

"}";

state_declaration = "states" "{" {state, ","} state "}" ";";
start_state = "start" state, ";";
accept_states = "accept" "{" { state } "}", ";";
state = identifier;

alphabet_declaration = "inputset" "{" {string, ","}, string "}", ";";

transition_declaration = dfa_transition;
dfa_transition = "transition" state, ":" { transition_rule }

transition_rule = "on" string,"," "goto" state, ";";

verification_declaration = "Verify" identifier "{"
property_list
"}";

property_list = { property, ";"};
property = reachable | acceptance | determinism | emptiness | equivalence;
reachable = "canreach" "{" { state, "," } state  "}";
acceptance = "accepts"  "{" { string,"," } string "}";
deerminism = "deterministic";
emptiness = "isEmpty";
equivalence = "equal" "{" { identifier,"," } identifier "}" ;
termination = "terminates" "{" { string, "," } string "}";

identifier = letter , { letter | digit | "_" } ;

letter =  "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z";

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

symbol = "[" | "]" | "{" | "}" | "(" | ")" | "&lt;" | "&gt;"
       | "'" | '"' | "=" | "|" | "." | "," | ";" | "-" 
       | "+" | "*" | "?" | "\n" | "\t" | "\r" | "\f" | "\b" ;

string = { character };
character = letter | digit | symbol | "_" | " " ;
</code></pre>
This Specification is prone to change of course. There are probably a lot of left recursions and ambiguities I need to sort out, This is the process so far.
I&rsquo;ve been successful in creating a lexical analyzer for this grammar using flex.
The topics of these series of blog posts will probably alternate between Compilers in general, and the Compiler I&rsquo;m writing.</p>

<h1>Lexical Analyzers</h1>

<p>What is a Lexical Analyzer?</p>

<p>Well to answer that question, the input stream ( input program ) of a compiler needs to first be analyzed in some lexical context.
Meaning that another program ( Lexer ) needs to first only look at these series of symbols, and decide what they represent lexically.
For example in a given stream <code>a = 2</code>, what is <code>a</code>? Is it a number? A string? Or perhaps an <code>IDENTIFIER</code>?
Doing this helps a lot when it comes to basic error detection and also paves the way for the parse r to function seamlessly.</p>

<h2>Symbol Table</h2>

<p>The symbol table is a universal data structure that keeps track of some token info to be shared by all phases of the compiler. Kinda like a universal Database among all phases lexer, parser, etc &hellip;</p>

<p>I&rsquo;ve also managed to make a functioning symbol table to use alongside the symbol table.</p>

<p>Let&rsquo;s see how far this project of mine makes it.</p>
    </div>

<h2 style="line-height:0"> Tags </h2>
<hr>
    
|  
<a href='https://xemadp.github.io/blog/tags/tutorial.html'>tutorial </a> |  
<a href='https://xemadp.github.io/blog/tags/technology.html'>technology </a> |  
<a href='https://xemadp.github.io/blog/tags/minddumps.html'>minddumps </a> |  
<a href='https://xemadp.github.io/blog/tags/learning.html'>learning </a> |  
<a href='https://xemadp.github.io/blog/tags/compilers.html'>compilers </a> |  

</body>
</head>
</html>
